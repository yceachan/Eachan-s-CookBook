# [题目描述:](https://www.luogu.com.cn/problem/P1004)

设有 N*×*N的方格图(*N*≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。如下图所示（见样例）:

```plain
A
 0  0  0  0  0  0  0  0
 0  0 13  0  0  6  0  0
 0  0  0  0  7  0  0  0
 0  0  0 14  0  0  0  0
 0 21  0  0  0  4  0  0
 0  0 15  0  0  0  0  0
 0 14  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
                         B
```

某人从图的左上角的 A*A* 点出发，可以向下行走，也可以向右走，直到到达右下角的 B*B* 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 00）。
此人从 A*A* 点到 B*B* 点共走两次，试找出 22 条这样的路径，使得取得的数之和为最大。

输入格式

输入的第一行为一个整数 N,接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 000 表示输入结束。

* 输出格式:

只需输出一个整数，表示 22 条路径上取得的最大的和。

* 输入输出样例:

  **输入 #1**

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

​      **输出 #1**

```
67
```

# 法一.四维动态规划

![img](https://cdn.luogu.com.cn/upload/usericon/42156.png)[**feecle6418** ](https://www.luogu.com.cn/user/42156)更新时间：2017-12-08 20:29:41[在 Ta 的博客查看](https://www.luogu.com.cn/blog/_post/113)

这题，是四维动规的模板题，和P1006传纸条基本相似。

我们考虑两个人同时走，就相当于数字三角形。状态转移方程为：

~~~
f[i][j][k][l]=max(f[i−1][j][k−1][l],f[i−1][j][k][l−1],f[i][j−1][k−1][l],f[i][j−1][k][l−1])+a[i][j]+a[k][l];
~~~

不过要判断i=k&&j=l的情况。

完整代码如下：

```cpp
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int f[12][12][12][12],a[12][12],n,x,y,z;
    int main() {
        cin>>n>>x>>y>>z;
        while(x!=0||y!=0||z!=0){
            a[x][y]=z;
            cin>>x>>y>>z;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    for(int l=1;l<=n;l++){
                        f[i][j][k][l]=max(max(f[i-1][j][k-1][l],f[i-1][j][k][l-1]),max(f[i][j-1][k-1][l],f[i][j-1][k][l-1]))+a[i][j]+a[k][l];
                        if(i==k&&l==j)f[i][j][k][l]-=a[i][j];
                    }
                }
            }
        }
        cout<<f[n][n][n][n];
        return 0;
}
```

# 法二.深度搜索

![img](https://cdn.luogu.com.cn/upload/usericon/42758.png)[**wzxx**](https://www.luogu.com.cn/user/42758)更新时间：2017-07-22 09:10:20[在 Ta 的博客查看](https://www.luogu.com.cn/blog/_post/866)

\###深搜深搜

见都是动规的帖子，来来来，贴一个深搜的题解（手动滑稽）。。。

这道题深搜的最优方法就是两种方案同时从起点出发。因为如果记录完第一种方案，再计算第二种方案，不可控的因素太多了，大多都不是最优解→_→，但两种方案同时执行就行，因为这可以根据当前的情况来判断最优。

总的来说，每走一步都会有四个分支（你理解成选择或者情况也可以）：

1、两种都向下走

2、第一种向下走，第二种向右走

3、第一种向右走，第二种向下走

4、两种都向右走

每走一步走枚举一下这四种情况，因为在每个点的方案具有唯一性（也就是在某个点走到终点的取数方案只有一个最优解，自己理解一下），所以我们可以开一个数组来记录每一种情况，当重复枚举到一种情况时就直接返回（对，就是剪枝），大大节省了时间（不然会超时哦~）。深搜和动归的时间复杂度时一样的！

附代码：

```cpp
//方格取数~深搜  ～(￣▽￣～)(～￣▽￣)～
#include<iostream>
    using namespace std;
    int N=0;
    int s[15][15],f[11][11][11][11];
int dfs(int x,int y,int x2,int y2)//两种方案同时执行，表示当第一种方案走到x,y,第二种方案走到x2,y2时到终点取得的最大数 
{
    if (f[x][y][x2][y2]!=-1) return f[x][y][x2][y2];//如果这种情况已经被记录过了，直接返回，节省时间 
    if (x==N&&y==N&&x2==N&&y2==N) return 0;//如果两种方案都走到了终点，返回结束 
    int M=0;
    //如果两种方案都不在最后一列，就都往下走，统计取得的数，如果有重复，就减去一部分 
    if (x<N&&x2<N) M=max(M,dfs(x+1,y,x2+1,y2)+s[x+1][y]+s[x2+1][y2]-s[x+1][y]*(x+1==x2+1&&y==y2));
    //如果第一种方案不在最后一行，第二种方案不在最后一列，第一种就向下走，第二种就向右走， 
    //统计取得的数，如果有重复，就减去一部分
    if (x<N&&y2<N) M=max(M,dfs(x+1,y,x2,y2+1)+s[x+1][y]+s[x2][y2+1]-s[x+1][y]*(x+1==x2&&y==y2+1));
    //如果第一种方案不在最后一列，第二种方案不在最后一行，第一种就向右走，第二种就向下走， 
    //统计取得的数，如果有重复，就减去一部分
    if (y<N&&x2<N) M=max(M,dfs(x,y+1,x2+1,y2)+s[x][y+1]+s[x2+1][y2]-s[x][y+1]*(x==x2+1&&y+1==y2));
    //如果第一种方案和第二种方案都不在最后一列，就都向右走，统计取得的数，如果有重复，就减去一部分
    if (y<N&&y2<N) M=max(M,dfs(x,y+1,x2,y2+1)+s[x][y+1]+s[x2][y2+1]-s[x][y+1]*(x==x2&&y+1==y2+1));
    //对最后那个 s[x][y+1]*(x==x2&&y+1==y2+1))的解释：这个是用来判断两种方案是不是走到了同一格的
    //如果是真，就返回1，否则返回0，如果是1的话，理所当然的可以减去s[x][y+1]*1,否则减去s[x][y+1]*0相当于
    //不减,写得有点精简，省了4个if，见谅哈~ 
    f[x][y][x2][y2]=M;//记录这种情况 
    return M;//返回最大值 
}
int main()
{
    cin>>N;
    //将记录数组初始化成-1，因为可能出现取的数为0的情况，如果直接判断f[x][y][x2][y2]!=0（见dfs第一行）
    //可能出现死循环而导致超时，细节问题 
    for(int a=0;a<=N;a++)
      for(int b=0;b<=N;b++)
        for(int c=0;c<=N;c++)
          for(int d=0;d<=N;d++) f[a][b][c][d]=-1;
    for(;;)//读入 
    {
        int t1=0,t2=0,t3=0;
        cin>>t1>>t2>>t3;
        if(t1==0&&t2==0&&t3==0) break;
        s[t1][t2]=t3;
    }
    cout<<dfs(1,1,1,1)+s[1][1];//输出，因为dfs中没有考虑第一格，即s[1][1]，所以最后要加一下 
    return 0;
}
```