

~~~C++
    void init() { for(int i=1;i<=n;i++) fa[i]=i;}
//并查集设计
	int fa[N], cnt = 0;
	int find(int x)
	{
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
//操作对象是ev的祖先和eu的祖先,这两个树的理想状态是两个二层的n叉树，合并为一个三层的二叉树，下次查询时继续压缩
	void unite(int lhs, int rhs)
	{
		fa[rhs] = find(lhs);
	}
~~~

并查集是有限空间内两个元素的某种作用关系的集合森林，初始化时我们暂定这种关系作用于自身，在传入信息，形如边`Edge:u→v`后，我们用一种映射`fa[rhs]=lhs`来描述和记忆这种可递推的关系,其状态压缩的改良是`fa[rhs] = fa[lhs];`

基于这种关系我们可以判断一组信息是否有效，形如`Edge:u→v`若出现`find(u)==find(v)`说明两点在同一关系树上，表现为图上的闭环

可以发现的是，最小生成树一定不是闭环的,且任加一边即可形成闭环。

并查集可以帮助我们发现闭环情况，对于非闭环目的的搜索，我们就需要“查”的状态空间的总数作为查找的次数依据即`cnt<n-1`

并查集很精巧，但并不全能，经常还需要设计其他东西来辅助



并查集巩固：find查：查询节点的祖先

unite并：归并**左节点祖先**和**右节点祖先**

**一个并查集树中，永远只有一个根节点，而其余节点在find查询中，递归访问dsu最终溯源到根节点**

而根节点也是在动态变化的，如若入了条新边，使$dsu[find(root)_{\equiv root}]$ =$find(new)$

考查unite序${(1,2),(1,3),(4,1),(5,1)}$,
$$
\begin{array} l
1.&(2,3):->1  &//find(2,3,1)=2,3,1\\ 
2.&(2,3):->1:->4 &//find(4,1)=4,1\\
3.&((2,3):->1:->4):->5&//find(5,1)=5,4
\end{array}
$$
考查unite序$(1,2),(2,3),(3,1)$
$$
\begin{array} l
1.&2:->1\\
2.&3:->2:->1\\
3.&(find(3)\equiv1):->1
\end{array}
$$