# 动态规划的问题特性与解题框架

## 引言

动态规划是算法与数据结构的重难点之一，其包含了「分治思想」、「空间换时间」、「最优解」等多种基石算法思想，常作为笔面试中的中等困难题出现。为帮助读者全面理解动态规划，知晓其来龙去脉，本文将从以下几个角度切入介绍：

1.动态规划问题特点，动态规划和分治算法的联系与区别；
2.借助例题介绍重叠子问题和最优子结构分别是什么，以及动态规划是如何解决它们的；
3.动态规划的解题框架总结；
4.动态规划的练习例题，从易到难排序；
5.动态规划特点

* 「分治」是算法中的一种基本思想，其通过将原问题分解为子问题，不断递归地将子问题分解为更小的子问题，并通过组合子问题的解来得到原问题的解。类似于分治算法，「动态规划」也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有「重叠子问题」和「最优子结构」两大特性。

## 重叠子问题

动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。

动态规划在第一次求解某子问题时，会将子问题的解保存；后续遇到重叠子问题时，则直接通过查表获取解，保证每个独立子问题只被计算一次，从而降低算法的时间复杂度。

### 解决策略——记忆，制表（线性记忆），动态规划（自底向上）

### [重叠1.质点记忆 jtOJ_juan ](https://blog.csdn.net/A_Midnight_Cat/article/details/114213623)

//对于当前n-k高分的dl的夺冠策略，就是依次给分数比他高的人附较少的分——这一步会大量的重复，而其中唯一有效的只是其中的最大值——我们从右向左遍历，始终记忆和更新Max，后继元素就只查询这个Max而不重复给前驱附分的操作

~~~C++
#include<iostream>
#include<algorithm>
using namespace std;

int n;
int res=1;
int* a = new int[n];
void scan() {

	
	cin >> n;

	for (int i = 0; i < n; i++) cin >> a[i];
	sort(a, a + n); //sort的参数是地址（迭代器）

}
//烂代码的味道，N^2 & 10^6
void badsln()
{
	
	scan();
	for (int i = 0; i < n; i++)
	{
		int* b = new int[n];
		bool flag = true;
		b[i] = a[i] + n;
		//为比他高分的同学尽可能都附上最少分
		for (int j = i + 1; j < n; j++)
		{
			b[j] = a[j]+n-(j-i);
			if (b[i] < b[j])
			{
				flag = false;
				break;
			}
		}
		if (flag) res++;
		delete[] b;
	}
	cout << res;
}
//我们从后往前给dl们依次探讨
int main()
{
	scan();
	int Max = a[n - 1] + 1;
	//从最高分降序依次找到比较可能拿第一名的人
	for (int i = n - 2; i >= 0; i--)
	{
		if (a[i] + n < Max)
		{
			break;
		}
		else {
			res++;
			//此时，对于分比i选手高的那些dl，依次为他们附上尽可能低的分即可——而我们需要的只是这样一个大佬序列里面分最高的那个人的分数信息
			Max = max(a[i] + n - i, Max);
		}
	}
	cout << res;
	delete[] a;
}
~~~

### 重叠2.记忆化递归fibonacci(n)

> f(x)=f(x-1) +f(x-2), f(1)=1,f(0)=0，先考查暴力递归

~~~C++
int fibonacci(int n)
{
    if(n==1) return 1;
    if(n==0) return 0;
    return fibonacci(1) + fibonacci(0);
}
/*递归深度2*n,单层O(1)，大量重复计算f（1），f（0）效率低下*/
~~~

>  线性记忆策略:第一次进入f（n）时，求解，记忆，后续进入f（n）时，返回解

~~~C++
map<int,long long>dp; || int* dp=new int [n];
long long  fiobonacci(int n)
{
	if (n == 1) return 1;
	if (n == 0) return 0;
	if (dp[n]) return dp[n];
	else
	{
		dp[n] = fiobonacci(n - 1) + fiobonacci(n - 2);
		return dp[n];
	}
}
//需要为0-n每个key制表，制表的递归深度为n，单层O(1)
//使用辅助映射map，空间复杂度O(n)
~~~

### 自底向上动态规划信息表

> 以上为自顶向下的递归策略
>
> 先设计自底向上构造好dp，减少栈调用开销

~~~C++
int fiobonacci(n)
{
    int* dp=new int[n];
    dp[0]=0;dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
}
~~~

我们追求的是：自顶向下分析，自底向上构建

## 最优子结构

如果一个问题的最优解可以由其子问题的最优解组合构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。

动态规划从基础问题的解开始，不断迭代组合、选择子问题的最优解，最终得到原问题最优解。

### 典型情景——背包问题

示例小结
本题同时包含「重叠子问题」和「最优子结构」，为动态规划的典型问题。动态规划通过填表避免了重复计算问题，并通过状态转移方程、初始状态实现对问题的迭代求解。

普遍来看，求最值 的问题一般都具有「重叠子问题」和「最优子结构」特点，因此此类问题往往适合用动态规划解决。

​	
